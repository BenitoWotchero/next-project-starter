# ğŸ“‹ Standard-Workflows - Wiederkehrende AblÃ¤ufe

> **Referenzierbare Workflows fÃ¼r Chat-Prompts und standardisierte Entwicklung**

## ğŸ¯ Verwendung in KI-Chats

**Chat-Prompts:**
```
"FÃ¼hre @docs/WORKFLOWS.MD â†’ RELEASE_WORKFLOW durch"
"Folge @docs/WORKFLOWS.MD â†’ FEATURE_DEVELOPMENT_WORKFLOW"
"Verwende @docs/WORKFLOWS.MD â†’ DOCUMENTATION_UPDATE_WORKFLOW"
```

---

## ğŸš€ RELEASE_WORKFLOW

### Ãœberblick
Standardisierter Release-Prozess mit Git Tags, Semantic Versioning und automatischer Dokumentation.

### Semantic Versioning Schema
```
MAJOR.MINOR.PATCH
  |     |     |
  |     |     â””â”€â”€ Bugfixes (1.2.3 â†’ 1.2.4)
  |     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Neue Features (1.2.4 â†’ 1.3.0)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Breaking Changes (1.3.0 â†’ 2.0.0)
```

**FÃ¼r Next.js Projekte:**
- **0.x.x** â†’ Development Phase
- **1.0.0** â†’ Erste produktive Version
- **1.x.x** â†’ Feature-Updates
- **2.0.0** â†’ Breaking Changes (API, Dependencies)

### Warum Git Tags verwenden?

**Git Tags = UnverÃ¤nderliche Versionsmarker**
```bash
# Tag erstellen
git tag v1.2.3

# Tag mit ausfÃ¼hrlicher Nachricht
git tag -a v1.2.3 -m "Version 1.2.3 - Feature Description

- Feature 1: Details
- Feature 2: Details
- Bugfixes: Details"

# Alle Tags anzeigen
git tag --list
```

**Warum separat pushen?**
```bash
git push origin main     # Pusht nur Commits
git push origin v1.2.3   # Pusht nur den Tag
git push --tags          # Pusht alle Tags
```

**Vorteile:**
1. **Kontrolle** â†’ Entscheiden welche Tags Ã¶ffentlich werden
2. **GitHub Releases** â†’ Tags triggern automatische Release-Notes
3. **Rollback-Sicherheit** â†’ Tags bleiben bei Force-Push bestehen
4. **Staging** â†’ Lokale Tags fÃ¼r Testing, Ã¶ffentliche fÃ¼r Releases

### Schritt-fÃ¼r-Schritt Workflow

#### 1. Pre-Release Checklist
- [ ] Alle geplanten Features implementiert
- [ ] Tests laufen durch (`npm run test`)
- [ ] Build erfolgreich (`npm run build`)
- [ ] Linting clean (`npm run lint`)

#### 2. Dokumentation aktualisieren
```bash
# CHANGELOG.md erweitern
## [X.Y.Z] - YYYY-MM-DD

### Added
- Neue Features beschreiben

### Changed
- GeÃ¤nderte FunktionalitÃ¤ten

### Fixed
- Behobene Bugs

### Technical
- Technische Ã„nderungen
- Warum diese Entscheidungen?
- Alternativen evaluiert?
```

```bash
# package.json Version erhÃ¶hen
{
  "version": "X.Y.Z"
}
```

```bash
# docs/OVERVIEW.MD aktualisieren
- Neue Features in entsprechenden Sections verlinken
- Erledigte Checkboxes abhaken
- Neue Priority-Items hinzufÃ¼gen
```

#### 3. Commit & Tag erstellen
```bash
# Alle Ã„nderungen hinzufÃ¼gen
git add .

# Commit mit strukturierter Message
git commit -m "feat: kurze Beschreibung

- Detaillierte Ã„nderung 1
- Detaillierte Ã„nderung 2
- Update version to X.Y.Z
- Update documentation"

# Tag erstellen
git tag vX.Y.Z

# Optional: Tag mit ausfÃ¼hrlicher Nachricht
git tag -a vX.Y.Z -m "Version X.Y.Z - Beschreibung

- Feature 1: Details
- Feature 2: Details
- Bugfixes: Details"
```

#### 4. Release pushen
```bash
# Code pushen
git push origin main

# Tag pushen (erstellt GitHub Release)
git push origin vX.Y.Z
```

#### 5. Post-Release
- [ ] GitHub Release Notes Ã¼berprÃ¼fen
- [ ] TODO-Listen in docs/OVERVIEW.MD aktualisieren (siehe TODO_UPDATE_WORKFLOW)
- [ ] Continuation-Prompt fÃ¼r nÃ¤chsten Chat generieren (siehe AI_CONTINUATION_WORKFLOW)
- [ ] Team/Stakeholder benachrichtigen

### Rollback bei Problemen
```bash
# Tag lÃ¶schen (lokal)
git tag -d vX.Y.Z

# Tag lÃ¶schen (remote)
git push origin :refs/tags/vX.Y.Z

# Commit rÃ¼ckgÃ¤ngig
git reset --hard HEAD~1
```

---

## ğŸ“‹ TODO_UPDATE_WORKFLOW

### Ãœberblick
Systematisches Aktualisieren der TODO-Listen vor jedem Release fÃ¼r bessere KI-Continuity.

### Warum TODO-Updates vor Release?
- **KI-Continuity** â†’ Neue Chats kÃ¶nnen direkt anknÃ¼pfen
- **Momentum halten** â†’ Klare nÃ¤chste Schritte definiert
- **PrioritÃ¤ten setzen** â†’ Focus auf wichtigste Entwicklungsbereiche

### Workflow-Schritte

#### 1. Erledigte Aufgaben abhaken
```markdown
# In docs/OVERVIEW.MD
- [x] â­ Feature X implementiert
- [x] API-Endpunkt Y erstellt
- [ ] â­ Feature Z (nÃ¤chste PrioritÃ¤t)
```

#### 2. Neue PrioritÃ¤ten basierend auf Release setzen
```markdown
## ğŸš€ EMPFOHLENE NÃ„CHSTE SCHRITTE (Post vX.Y.Z)

> **HinzugefÃ¼gt nach vX.Y.Z Release** - [Release-Beschreibung]

### ğŸ¯ **SOFORTIGER FOKUS: [HauptprioritÃ¤t]**
**Warum [diese PrioritÃ¤t]?** [BegrÃ¼ndung basierend auf Release-Stand]

#### **Phase 1: [Kurzziel] (ZeitschÃ¤tzung)**
1. **[Konkreter Schritt 1]**
2. **[Konkreter Schritt 2]**

#### **Phase 2: [Mittelfristziel] (ZeitschÃ¤tzung)**
- [Detaillierte Aufgaben]

### ğŸ“… **[ZEITRAUM] ROADMAP**
- [ ] **Tag X:** [Spezifische Aufgabe]
- [ ] **Tag Y:** [Spezifische Aufgabe]

### ğŸ› ï¸ **TECHNISCHE EMPFEHLUNGEN**
- [Konkrete Tech-Entscheidungen]
- [Tool-Empfehlungen mit BegrÃ¼ndung]

### âš ï¸ **KRITISCHE ENTSCHEIDUNGEN DIESE WOCHE**
1. [Entscheidung 1]
2. [Entscheidung 2]

â†’ **[Fokus-Statement fÃ¼r Richtung]**
```

#### 3. Spezifische Arbeitsbereich-TODOs erweitern
```markdown
# Beispiel fÃ¼r Frontend-TODOs
### ğŸ¨ UI/UX TODO-Updates
- [ ] Component X: State-Management optimieren
- [ ] Page Y: Mobile Responsiveness verbessern
- [ ] Feature Z: Accessibility-Compliance sicherstellen

**NÃ¤chster Chat-Fokus:** "Arbeite an Component X State-Management"
```

#### 4. KI-Chat Prompts vorbereiten
```markdown
# FÃ¼r nÃ¤chsten Chat
**Quick-Start-Prompts:**
- "Implementiere Component X State-Management aus @docs/OVERVIEW.MD"
- "Optimiere Mobile Responsiveness fÃ¼r Page Y"
- "Review und verbessere Accessibility fÃ¼r Feature Z"
```

### Template fÃ¼r TODO-Section Updates
```markdown
## âš¡ NACH RELEASE vX.Y.Z - NÃ„CHSTE SCHRITTE

### Was ist jetzt anders?
- [Release hat X ermÃ¶glicht]
- [Neue MÃ¶glichkeiten durch Y]
- [NÃ¤chste logische Schritte sind Z]

### Top 3 PrioritÃ¤ten
1. **[PRIO 1]** â†’ [Warum wichtig] â†’ [ZeitschÃ¤tzung]
2. **[PRIO 2]** â†’ [Warum wichtig] â†’ [ZeitschÃ¤tzung]
3. **[PRIO 3]** â†’ [Warum wichtig] â†’ [ZeitschÃ¤tzung]

### FÃ¼r nÃ¤chsten KI-Chat
**Empfohlener Start:** "[Konkreter Arbeitsauftrag mit @file-Referenz]"
```

---

## ğŸ”„ FEATURE_DEVELOPMENT_WORKFLOW

### Ãœberblick
Strukturierter Workflow fÃ¼r Feature-Entwicklung von Konzept bis Release.

### Workflow-Schritte

#### 1. Feature Planning
```markdown
# Feature-Template erstellen
## ğŸ¯ [FEATURE_NAME]

### Problem/Bedarf
- Was lÃ¶st dieses Feature?
- FÃ¼r wen ist es gedacht?

### LÃ¶sung
- Wie lÃ¶sen wir das Problem?
- Warum diese LÃ¶sung?

### Technische Implementierung
- Welche Komponenten betroffen?
- Neue Dependencies?
- Breaking Changes?

### Acceptance Criteria
- [ ] Kriterium 1
- [ ] Kriterium 2

### Testing Strategy
- Unit Tests fÃ¼r...
- Integration Tests fÃ¼r...
- E2E Tests fÃ¼r...
```

#### 2. Implementation
```bash
# Feature Branch erstellen
git checkout -b feature/feature-name

# Entwicklung in kleinen Commits
git commit -m "feat(component): add basic structure"
git commit -m "feat(component): implement core logic"
git commit -m "test(component): add unit tests"
```

#### 3. Documentation wÃ¤hrend Development
- [ ] Code-Kommentare hinzufÃ¼gen
- [ ] README.md aktualisieren (falls nÃ¶tig)
- [ ] API-Dokumentation erweitern
- [ ] Component-Dokumentation (Storybook)

#### 4. Testing & Review
```bash
# Tests ausfÃ¼hren
npm run test
npm run lint
npm run type-check
npm run build

# Code Review vorbereiten
git push origin feature/feature-name
# Pull Request erstellen
```

#### 5. Merge & Cleanup
```bash
# Nach Merge: Branch lÃ¶schen
git branch -d feature/feature-name
git push origin --delete feature/feature-name

# Lokale Branches aufrÃ¤umen
git remote prune origin
```

---

## ğŸ“š DOCUMENTATION_UPDATE_WORKFLOW

### Ãœberblick
Systematisches Aktualisieren der Projektdokumentation.

### RegelmÃ¤ÃŸige Dokumentations-Reviews

#### WÃ¶chentlich
- [ ] CHANGELOG.md aktuell?
- [ ] README.md reflects current state?
- [ ] TODO-Listen in docs/OVERVIEW.MD abhaken

#### Monatlich
- [ ] docs/OVERVIEW.MD vollstÃ¤ndig durchgehen
- [ ] Verwaiste Dokumentations-Files identifizieren
- [ ] Broken Links reparieren (`npm run ai-check`)
- [ ] Veraltete Sections als deprecated markieren

#### Bei jedem Release
- [ ] Alle neuen Features dokumentiert
- [ ] API-Ã„nderungen dokumentiert
- [ ] Breaking Changes prominent markiert
- [ ] Migration-Guides erstellt (bei Breaking Changes)

### Documentation Debt Management
```markdown
## Documentation Debt Log

### Identified Issues
- [ ] Section X needs updating (Reason: Feature Y added)
- [ ] File Z is outdated (Reason: API changed)

### Deprecation Queue
- [ ] Old workflow A â†’ Replace with workflow B
- [ ] Legacy component docs â†’ Update for new patterns

### Content Strategy
- Focus on "Why" not just "What"
- Include decision rationales
- Add troubleshooting sections
- Keep getting-started path clear
```

---

## ğŸ¤– AI_CHAT_CONTINUATION_WORKFLOW

### Ãœberblick
Workflow fÃ¼r nahtlose Weiterarbeit zwischen Chat-Sessions.

### Template fÃ¼r Chat-Ãœbergang
```markdown
Howdie partner! Arbeite an [PROJECT_NAME].

**AKTUELLER STATUS (Version X.Y.Z):**
[Aktuelle Meilensteine aus docs/OVERVIEW.MD]

**LETZTER ARBEITSBEREICH:** [Was zuletzt bearbeitet wurde]

**VERFÃœGBARE BEREICHE:**
- ğŸ—ï¸ Architecture & Setup
- ğŸ’» Development & Features  
- ğŸ“š Documentation
- ğŸš€ Deployment & DevOps
- ğŸ§ª Testing & QA

**LETZTE Ã„NDERUNGEN:**
[Aus CHANGELOG.md neueste Version]

**BEKANNTE ISSUES:**
[Aus docs/OVERVIEW.MD oder GitHub Issues]

Bitte lies @docs/OVERVIEW.MD fÃ¼r vollstÃ¤ndigen Kontext.

**WAS SOLL ICH HEUTE BEARBEITEN?**
[Konkrete Optionen basierend auf aktueller Projektphase]
```

### Context-Keeper fÃ¼r lange Chats
```markdown
## ğŸ§  CONTEXT REFRESH

**Projekt:** [PROJECT_NAME]
**Phase:** [Development/Testing/Production]
**Letzte Ã„nderung:** [Kurze Beschreibung]

**Aktuelle Aufgabe:** 
[Was gerade bearbeitet wird]

**NÃ¤chste Schritte:**
1. [Konkreter nÃ¤chster Schritt]
2. [Danach kommt...]

**Wichtige Entscheidungen heute:**
- [Entscheidung 1 mit BegrÃ¼ndung]
- [Entscheidung 2 mit BegrÃ¼ndung]
```

---

## ğŸ§ª TESTING_WORKFLOW

### Ãœberblick
Systematisches Testing von der Entwicklung bis zum Release.

### Test-Pyramid fÃ¼r Next.js

#### Unit Tests (Basis)
```bash
# Komponenten-Tests
npm run test:unit

# Was testen?
- Einzelne Funktionen
- React-Komponenten isoliert
- Utility-Functions
- API-Route-Handler
```

#### Integration Tests (Mitte)
```bash
# API-Integration
npm run test:integration

# Was testen?
- API-Endpunkt-Kombinationen
- Datenbank-Interaktionen
- Service-Integrationen
- Komponentengruppen
```

#### E2E Tests (Spitze)
```bash
# User-Journeys
npm run test:e2e

# Was testen?
- Kritische User-Flows
- Happy Path Scenarios
- Error-Handling-Flows
- Cross-Browser-Compatibility
```

### Pre-Commit Testing
```bash
# Automated testing hook
npm run pre-commit
# FÃ¼hrt aus: lint + type-check + unit-tests
```

### Release Testing Checklist
- [ ] All automated tests pass
- [ ] Manual smoke tests completed
- [ ] Performance tests (if applicable)
- [ ] Security tests (if applicable)
- [ ] Browser compatibility tested
- [ ] Mobile responsiveness verified

---

## ğŸ”§ DEPENDENCY_UPDATE_WORKFLOW

### Ãœberblick
Systematisches Updaten von Dependencies ohne Breaking Changes.

### Monthly Dependency Review
```bash
# Check outdated packages
npm outdated

# Security audit
npm audit

# Update strategy
npm run deps:update
```

### Update Categories

#### Patch Updates (Automatisch)
```bash
# Safe updates
npm update
```

#### Minor Updates (Review)
```bash
# Review breaking changes
npm install package@latest
# Test thoroughly
npm run test:all
```

#### Major Updates (Planned)
```bash
# Plan in advance
# Create feature branch
# Update one by one
# Extensive testing
# Documentation updates
```

### Rollback Strategy
```bash
# Package-lock.json backup
cp package-lock.json package-lock.backup.json

# Quick rollback
git checkout HEAD -- package-lock.json
npm ci
```

---

## ğŸš¨ EMERGENCY_HOTFIX_WORKFLOW

### Ãœberblick
Schnelle Fehlerbehebung fÃ¼r produktive Systeme.

### Hotfix-Prozess

#### 1. Hotfix Branch
```bash
# Von main/master Branch
git checkout -b hotfix/critical-bug-fix

# Minimale Ã„nderung
# Nur der Bug-Fix, keine Features!
```

#### 2. Schnelle Tests
```bash
# Nur relevante Tests
npm run test -- --testPathPattern=affected
npm run build
```

#### 3. Express Release
```bash
# Patch-Version erhÃ¶hen
# Minimal CHANGELOG
# Schneller Release
```

#### 4. Post-Hotfix
```bash
# Hotfix in development branch mergen
# Ursachen-Analyse
# PrÃ¤ventive MaÃŸnahmen planen
```

---

## ğŸ“‹ Workflow-Referenz

### Quick Commands
```bash
# Release durchfÃ¼hren
npm run release

# Dokumentation prÃ¼fen  
npm run ai-check

# Projekt validieren
npm run validate

# Tests ausfÃ¼hren
npm run test:all
```

### Workflow-Files Struktur
```
docs/
â”œâ”€â”€ WORKFLOWS.MD           # Diese Datei - Alle Workflows
â”œâ”€â”€ OVERVIEW.MD            # Master-Ãœbersicht  
â”œâ”€â”€ CHECKLIST.MD           # Quality Gates
â””â”€â”€ workflows/             # Detaillierte Workflow-Docs
    â”œâ”€â”€ release.md         # Detaillierter Release-Guide
    â”œâ”€â”€ feature-dev.md     # Feature-Development Details
    â”œâ”€â”€ documentation.md   # Doc-Management Details
    â””â”€â”€ emergency.md       # Notfall-Prozeduren
```

---

**ğŸ’¡ Verwendung:** Referenziere diese Workflows in KI-Chats mit `@docs/WORKFLOWS.MD â†’ [WORKFLOW_NAME]` fÃ¼r standardisierte AblÃ¤ufe.

**ğŸ”„ Updates:** Diese Workflows werden bei jedem Release-Workflow aktualisiert und verbessert.

---

## ğŸ“ Erweiterte Workflows

FÃ¼r spezielle wiederkehrende AblÃ¤ufe siehe:
- **[workflows/ADDITIONAL_WORKFLOWS.md](workflows/ADDITIONAL_WORKFLOWS.md)** â†’ ğŸ§¹ Cleanup, âš¡ Performance, ğŸ”’ Security, ğŸ¨ Design, ğŸš€ Client-Handover, ğŸ’¾ Backup, ğŸ“Š Analytics, ğŸ¯ Scope-Management, ğŸ”„ Dependencies, ğŸ“± Mobile-Testing

### Quick-Referenz fÃ¼r Chat-Prompts:
```
"FÃ¼hre @docs/workflows/ADDITIONAL_WORKFLOWS.md â†’ PROJECT_CLEANUP_WORKFLOW durch"
"FÃ¼hre @docs/workflows/ADDITIONAL_WORKFLOWS.md â†’ PERFORMANCE_AUDIT_WORKFLOW durch"
"FÃ¼hre @docs/workflows/ADDITIONAL_WORKFLOWS.md â†’ SECURITY_REVIEW_WORKFLOW durch"
"FÃ¼hre @docs/workflows/ADDITIONAL_WORKFLOWS.md â†’ CLIENT_HANDOVER_WORKFLOW durch"
``` 